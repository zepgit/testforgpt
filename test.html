<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Single-file Tetris</title>
  <style>
    :root{
      --bg:#0f1720;
      --panel:#0b1220;
      --accent:#7dd3fc;
      --muted:#94a3b8;
      --tile-size:28px;
    }
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(180deg,#071023 0%, #081222 60%);
      color:#e6eef6;
    }
    .container{
      display:flex;
      gap:18px;
      align-items:flex-start;
      padding:20px;
    }
    canvas{
      background:linear-gradient(180deg,#071428 0%, #041021 100%);
      border-radius:8px;
      box-shadow: 0 8px 30px rgba(2,6,23,.6), inset 0 -2px 6px rgba(255,255,255,.02);
      image-rendering: crisp-edges;
    }
    .side{
      width:220px;
      background:linear-gradient(180deg,var(--panel),#07101a);
      border-radius:8px;
      padding:12px;
      box-shadow: 0 6px 18px rgba(2,6,23,.6);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .side h1{margin:0;font-size:16px;color:var(--accent);letter-spacing:.6px}
    .stat{font-size:14px;color:var(--muted);display:flex;justify-content:space-between}
    .next, .hold{display:grid;grid-template-columns:repeat(4,1fr);gap:2px;background:#021018;padding:8px;border-radius:6px}
    .tile{
      width:var(--tile-size);
      height:var(--tile-size);
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      border-radius:3px;
    }
    .controls{font-size:13px;color:var(--muted);line-height:1.45}
    .buttons{display:flex;gap:8px;margin-top:6px;flex-wrap:wrap}
    button{
      background:transparent;border:1px solid rgba(255,255,255,.05);color:var(--muted);padding:8px;border-radius:6px;cursor:pointer;
    }
    button.primary{background:var(--accent);color:#04202a;border:0;font-weight:600}
    footer{font-size:12px;color:#9fb3c8;margin-top:6px}
    @media (max-width:720px){
      .container{flex-direction:column;align-items:center}
      .side{width:100%;max-width:420px}
      canvas{width:320px;height:640px}
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Tetris game">
    <canvas id="board" width="280" height="560"></canvas>
    <div class="side" aria-hidden="false">
      <h1>Single-file Tetris</h1>
      <div class="stat"><span>Score</span><strong id="score">0</strong></div>
      <div class="stat"><span>Level</span><strong id="level">0</strong></div>
      <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>

      <div style="display:flex;gap:8px">
        <div style="flex:1">
          <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Next</div>
          <div class="next" id="next"></div>
        </div>
        <div style="width:92px">
          <div style="font-size:12px;color:var(--muted);margin-bottom:6px">Hold</div>
          <div class="hold" id="hold"></div>
        </div>
      </div>

      <div class="controls" aria-hidden="false">
        <div><strong>Keys</strong></div>
        <div>← → : Move &nbsp; ↑ : Rotate CW &nbsp; Z : Rotate CCW</div>
        <div>↓ : Soft drop &nbsp; Space : Hard drop &nbsp; C : Hold</div>
        <div>P : Pause &nbsp; R : Restart</div>

        <div class="buttons">
          <button id="btn-pause">Pause</button>
          <button id="btn-restart" class="primary">Restart</button>
        </div>
      </div>

      <footer>Implemented in one file — enjoy!</footer>
    </div>
  </div>

<script>
(() => {
  // Configuration
  const COLS = 10, ROWS = 20;
  const TILE = 28; // visual size (matches CSS variable)
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const nextEl = document.getElementById('next');
  const holdEl = document.getElementById('hold');
  const btnPause = document.getElementById('btn-pause');
  const btnRestart = document.getElementById('btn-restart');

  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;

  // Tetromino definitions (matrix rotations)
  // Represent each tetromino as an array of rotation states (2D arrays).
  const TETROMINOES = {
    I: [
      [[0,0,0,0],
       [1,1,1,1],
       [0,0,0,0],
       [0,0,0,0]],
      [[0,0,1,0],
       [0,0,1,0],
       [0,0,1,0],
       [0,0,1,0]]
    ],
    J: [
      [[1,0,0],
       [1,1,1],
       [0,0,0]],
      [[0,1,1],
       [0,1,0],
       [0,1,0]],
      [[0,0,0],
       [1,1,1],
       [0,0,1]],
      [[0,1,0],
       [0,1,0],
       [1,1,0]],
    ],
    L: [
      [[0,0,1],
       [1,1,1],
       [0,0,0]],
      [[0,1,0],
       [0,1,0],
       [0,1,1]],
      [[0,0,0],
       [1,1,1],
       [1,0,0]],
      [[1,1,0],
       [0,1,0],
       [0,1,0]]
    ],
    O: [
      [[1,1],
       [1,1]]
    ],
    S: [
      [[0,1,1],
       [1,1,0],
       [0,0,0]],
      [[0,1,0],
       [0,1,1],
       [0,0,1]]
    ],
    T: [
      [[0,1,0],
       [1,1,1],
       [0,0,0]],
      [[0,1,0],
       [0,1,1],
       [0,1,0]],
      [[0,0,0],
       [1,1,1],
       [0,1,0]],
      [[0,1,0],
       [1,1,0],
       [0,1,0]]
    ],
    Z: [
      [[1,1,0],
       [0,1,1],
       [0,0,0]],
      [[0,0,1],
       [0,1,1],
       [0,1,0]]
    ]
  };

  const COLORS = {
    I:'#4dd0e1',
    J:'#7c4dff',
    L:'#ffb74d',
    O:'#ffd54f',
    S:'#66bb6a',
    T:'#ef7aa1',
    Z:'#f06292',
    X:'#263238' // board block
  };

  // Game state
  let board, current, nextQueue, holdPiece, canHold;
  let score=0, level=0, lines=0;
  let gravityInterval = 800; // ms initial
  let dropTimer = 0, lastTime = 0;
  let running = false, paused=false, gameOver=false;
  let softDrop = false;

  function createBoard(){
    const b = [];
    for(let r=0;r<ROWS;r++){
      b[r] = new Array(COLS).fill(0);
    }
    return b;
  }

  function randBag(){
    const bag = Object.keys(TETROMINOES);
    for(let i=bag.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [bag[i],bag[j]]=[bag[j],bag[i]];
    }
    return bag;
  }

  function makeQueue(){
    const q = [];
    let bag = [];
    while(q.length<6){
      if(bag.length===0) bag = randBag();
      q.push(bag.pop());
    }
    return q;
  }

  function newPiece(type){
    const rotations = TETROMINOES[type];
    const stateIdx = 0;
    const matrix = cloneMatrix(rotations[stateIdx]);
    // start near top center
    const x = Math.floor((COLS - matrix[0].length)/2);
    const y = -matrix.length; // allow spawn above top
    return {type, matrix, rot: stateIdx, x, y};
  }

  function cloneMatrix(m){
    return m.map(r=>r.slice());
  }

  function rotateMatrix(m, cw=true){
    const rows = m.length, cols = m[0].length;
    const res = Array.from({length:cols}, ()=>new Array(rows).fill(0));
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(cw) res[c][rows-1-r]=m[r][c];
        else res[cols-1-c][r]=m[r][c];
      }
    }
    return res;
  }

  function placePiece(){
    const {matrix,x,y,type} = current;
    for(let r=0;r<matrix.length;r++){
      for(let c=0;c<matrix[r].length;c++){
        if(matrix[r][c]){
          const br = y + r;
          const bc = x + c;
          if(br>=0 && br<ROWS && bc>=0 && bc<COLS){
            board[br][bc] = type;
          }
        }
      }
    }
  }

  function validPosition(matrix, x, y){
    for(let r=0;r<matrix.length;r++){
      for(let c=0;c<matrix[r].length;c++){
        if(matrix[r][c]){
          const br = y + r;
          const bc = x + c;
          if(bc<0 || bc>=COLS) return false;
          if(br>=ROWS) return false;
          if(br>=0 && board[br][bc]) return false;
        }
      }
    }
    return true;
  }

  // Basic wall-kick: try offsets
  function tryRotate(cw=true){
    const type = current.type;
    const rots = TETROMINOES[type];
    const nextRot = (current.rot + (cw?1:rots.length-1)) % rots.length;
    let newMatrix = cloneMatrix(rots[nextRot]);
    const offsets = [0, -1, 1, -2, 2];
    for(const off of offsets){
      if(validPosition(newMatrix, current.x + off, current.y)){
        current.matrix = newMatrix;
        current.rot = nextRot;
        current.x += off;
        return true;
      }
    }
    return false;
  }

  function spawnFromQueue(){
    const type = nextQueue.shift();
    nextQueue.push(...(makeQueue()));
    const p = newPiece(type);
    current = p;
    canHold = true;
    // If spawn collides immediately -> game over
    if(!validPosition(current.matrix, current.x, current.y)){
      gameOver = true;
      running = false;
    }
    renderSide();
  }

  function hold(){
    if(!canHold || gameOver || !running) return;
    if(!holdPiece){
      holdPiece = current.type;
      spawnFromQueue();
    } else {
      const swap = holdPiece;
      holdPiece = current.type;
      current = newPiece(swap);
      current.x = Math.floor((COLS - current.matrix[0].length)/2);
      current.y = -current.matrix.length;
      if(!validPosition(current.matrix, current.x, current.y)){
        gameOver = true; running=false;
      }
    }
    canHold=false;
    renderSide();
  }

  function hardDrop(){
    if(gameOver || !running) return;
    while(validPosition(current.matrix, current.x, current.y+1)){
      current.y++;
      score += 2; // small reward for each hard drop step
    }
    lockPiece();
  }

  function lockPiece(){
    placePiece();
    const cleared = clearLines();
    // scoring
    const levelMult = (level+1);
    const scoreFor = {0:0,1:40,2:100,3:300,4:1200};
    score += (scoreFor[cleared] || 0) * levelMult;
    // update level per lines (classic: every 10 lines)
    lines += cleared;
    const newLevel = Math.floor(lines/10);
    if(newLevel > level){
      level = newLevel;
      gravityInterval = Math.max(80, 800 - level*60); // accelerate
    }
    // spawn next
    spawnFromQueue();
    // Check end condition when spawn fails is done in spawnFromQueue
    updateHUD();
  }

  function clearLines(){
    let cleared = 0;
    for(let r=ROWS-1;r>=0;r--){
      if(board[r].every(cell=>cell!==0)){
        board.splice(r,1);
        board.unshift(new Array(COLS).fill(0));
        cleared++;
        r++; // re-check same row after shift
      }
    }
    return cleared;
  }

  function softDropStart(){ softDrop = true; }
  function softDropStop(){ softDrop = false; }

  function update(dt){
    if(!running || paused || gameOver) return;
    dropTimer += dt;
    const interval = softDrop ? 50 : gravityInterval;
    if(dropTimer >= interval){
      dropTimer = 0;
      if(validPosition(current.matrix, current.x, current.y+1)){
        current.y++;
      } else {
        lockPiece();
      }
    }
  }

  function step(ts){
    if(!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;
    update(dt);
    draw();
    if(running) requestAnimationFrame(step);
    else if(gameOver) draw(true);
  }

  // Drawing functions
  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(0,0);
    ctx.fillStyle = '#021425';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // draw existing board
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const val = board[r][c];
        if(val){
          drawCell(c, r, COLORS[val] || COLORS.X);
        } else {
          // subtle grid lines
          ctx.strokeStyle = 'rgba(255,255,255,.02)';
          ctx.strokeRect(c*TILE, r*TILE, TILE, TILE);
        }
      }
    }
    // draw current piece
    if(current){
      for(let r=0;r<current.matrix.length;r++){
        for(let c=0;c<current.matrix[r].length;c++){
          if(current.matrix[r][c]){
            const br = current.y + r;
            const bc = current.x + c;
            if(br>=0) drawCell(bc, br, COLORS[current.type]);
            else {
              // draw partially above board with transparency
              ctx.globalAlpha = 0.6;
              drawCell(bc, br, COLORS[current.type]);
              ctx.globalAlpha = 1;
            }
          }
        }
      }
    }
    ctx.restore();
  }

  function drawCell(col, row, color){
    const x = col * TILE;
    const y = row * TILE;
    // background
    ctx.fillStyle = color;
    ctx.fillRect(x+1, y+1, TILE-2, TILE-2);
    // highlight/shadow
    ctx.fillStyle = hexToRgba(color, .18);
    ctx.fillRect(x+1, y+1, TILE-2, (TILE-2)/2);
    ctx.strokeStyle = hexToRgba('#000', .25);
    ctx.strokeRect(x+1, y+1, TILE-2, TILE-2);
  }

  function hexToRgba(hex, a){
    const c = hex.replace('#','');
    const r = parseInt(c.substring(0,2),16);
    const g = parseInt(c.substring(2,4),16);
    const b = parseInt(c.substring(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  function draw(highlightGameOver=false){
    drawGrid();
    if(highlightGameOver){
      ctx.fillStyle = 'rgba(2,6,23,0.7)';
      ctx.fillRect(0, canvas.height/2 - 40, canvas.width, 80);
      ctx.fillStyle = '#ffd7da';
      ctx.font = '20px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width/2, canvas.height/2+6);
    }
  }

  function updateHUD(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function renderMini(matrix, container, color){
    // Clear
    container.innerHTML = '';
    const size = 4; // 4x4 grid for preview
    const tile = document.createElement('div');
    // We'll just append tile elements
    const frag = document.createDocumentFragment();
    // Determine width/height of the matrix
    const w = matrix[0].length;
    const h = matrix.length;
    // center the piece in a 4x4
    const offsetX = Math.floor((4 - w)/2);
    const offsetY = Math.floor((4 - h)/2);
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        const el = document.createElement('div');
        el.className = 'tile';
        el.style.width = (TILE-6)+'px';
        el.style.height = (TILE-6)+'px';
        el.style.background = 'transparent';
        el.style.border = '1px solid rgba(255,255,255,.02)';
        frag.appendChild(el);
      }
    }
    container.appendChild(frag);
    // fill with piece cells
    const tiles = container.querySelectorAll('.tile');
    for(let r=0;r<matrix.length;r++){
      for(let c=0;c<matrix[0].length;c++){
        if(matrix[r][c]){
          const idx = (r+offsetY)*4 + (c+offsetX);
          if(tiles[idx]) tiles[idx].style.background = color;
        }
      }
    }
  }

  function renderSide(){
    // Next: render next[0..5] as small matrices using first rotation
    nextEl.innerHTML = '';
    // create 6x4 grid visually for next
    nextQueue.slice(0,6).forEach((type)=>{
      const mat = TETROMINOES[type][0];
      const wrapper = document.createElement('div');
      wrapper.className = 'tile';
      wrapper.style.width = ((TILE-6)*4 + 6) + 'px'; // single wide tile used as container
    });
    // But instead we render 6 mini-previews inside the grid cells
    // Build a temporary container for each preview
    nextEl.innerHTML = '';
    for(let i=0;i<6;i++){
      const box = document.createElement('div');
      box.style.width = '100%';
      box.style.height = (TILE*4/4)+'px';
      box.style.display = 'flex';
      box.style.alignItems = 'center';
      box.style.justifyContent = 'center';
      const inner = document.createElement('div');
      inner.style.display = 'grid';
      inner.style.gridTemplateColumns = 'repeat(4, '+(TILE-8)+'px)';
      inner.style.gridAutoRows = (TILE-8)+'px';
      inner.style.gap = '2px';
      inner.style.background = 'transparent';
      for(let r=0;r<4;r++){
        for(let c=0;c<4;c++){
          const t = document.createElement('div');
          t.style.width = (TILE-8)+'px';
          t.style.height = (TILE-8)+'px';
          t.style.border = '1px solid rgba(255,255,255,.02)';
          t.style.background = 'transparent';
          inner.appendChild(t);
        }
      }
      const type = nextQueue[i];
      if(type){
        const mat = TETROMINOES[type][0];
        const offsetX = Math.floor((4 - mat[0].length)/2);
        const offsetY = Math.floor((4 - mat.length)/2);
        for(let r=0;r<mat.length;r++){
          for(let c=0;c<mat[r].length;c++){
            if(mat[r][c]){
              const idx = (r+offsetY)*4 + (c+offsetX);
              inner.children[idx].style.background = COLORS[type];
            }
          }
        }
      }
      box.appendChild(inner);
      nextEl.appendChild(box);
    }

    // Hold
    holdEl.innerHTML = '';
    for(let r=0;r<2;r++){
      for(let c=0;c<2;c++){
        const t = document.createElement('div');
        t.className = 'tile';
        t.style.width = (TILE-6)+'px';
        t.style.height = (TILE-6)+'px';
        t.style.border = '1px solid rgba(255,255,255,.02)';
        t.style.background = 'transparent';
        holdEl.appendChild(t);
      }
    }
    if(holdPiece){
      const mat = TETROMINOES[holdPiece][0];
      const offsetX = Math.floor((2 - mat[0].length)/2);
      const offsetY = Math.floor((2 - mat.length)/2);
      for(let r=0;r<mat.length;r++){
        for(let c=0;c<mat[r].length;c++){
          if(mat[r][c]){
            const idx = (r+offsetY)*2 + (c+offsetX);
            if(holdEl.children[idx]) holdEl.children[idx].style.background = COLORS[holdPiece];
          }
        }
      }
    }
    updateHUD();
  }

  // Input handling
  const keys = {};
  window.addEventListener('keydown', e=>{
    if(e.repeat) return;
    const k = e.key.toLowerCase();
    if(k === 'arrowleft'){ move(-1); e.preventDefault(); return; }
    if(k === 'arrowright'){ move(1); e.preventDefault(); return; }
    if(k === 'arrowdown'){ softDropStart(); e.preventDefault(); return; }
    if(k === 'arrowup'){ rotate(true); e.preventDefault(); return; }
    if(k === 'z'){ rotate(false); e.preventDefault(); return; }
    if(k === 'x'){ rotate(true); e.preventDefault(); return; }
    if(k === ' '){ hardDrop(); e.preventDefault(); return; }
    if(k === 'c'){ hold(); e.preventDefault(); return; }
    if(k === 'p'){ togglePause(); e.preventDefault(); return; }
    if(k === 'r'){ start(); e.preventDefault(); return; }
  });
  window.addEventListener('keyup', e=>{
    const k = e.key.toLowerCase();
    if(k === 'arrowdown'){ softDropStop(); }
  });

  function move(dir){
    if(!running || paused || gameOver) return;
    if(validPosition(current.matrix, current.x + dir, current.y)){
      current.x += dir;
    }
  }
  function rotate(cw=true){
    if(!running || paused || gameOver) return;
    tryRotate(cw);
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    btnPause.textContent = paused ? 'Resume' : 'Pause';
    if(!paused && running) {
      lastTime = performance.now();
      requestAnimationFrame(step);
    }
  }

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', start);

  // Start/reset game
  function start(){
    board = createBoard();
    nextQueue = makeQueue();
    holdPiece = null;
    canHold = true;
    score = 0; level = 0; lines = 0;
    gravityInterval = 800;
    gameOver = false;
    running = true;
    paused = false;
    current = null;
    // spawn two pieces to fill current
    spawnFromQueue();
    updateHUD();
    renderSide();
    lastTime = 0;
    requestAnimationFrame(step);
  }

  // Initialize small preview DOM
  renderSide();
  // start immediately
  start();

  // Expose some debug to window
  window.__tetris = {start, board};

})();
</script>
</body>
</html>
